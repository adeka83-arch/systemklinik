// Database Backup Service
// Handles database export and backup operations

interface BackupResult {
  success: boolean
  data?: string
  size?: string
  error?: string
  timestamp: string
}

export class DatabaseBackupService {
  private accessToken: string
  private serverUrl: string

  constructor(accessToken: string, serverUrl: string) {
    this.accessToken = accessToken
    this.serverUrl = serverUrl
  }

  /**
   * Create full database backup
   */
  async createBackup(): Promise<BackupResult> {
    const timestamp = new Date().toISOString()
    
    try {
      console.log('🔄 Starting database backup...')
      
      // Get all data from different endpoints
      const backupData = await this.exportAllData()
      
      if (!backupData.success) {
        return {
          success: false,
          error: backupData.error,
          timestamp
        }
      }

      // Generate SQL dump
      const sqlDump = this.generateSQLDump(backupData.data!, timestamp)
      const size = this.formatFileSize(new Blob([sqlDump]).size)

      console.log('✅ Database backup created successfully')
      
      return {
        success: true,
        data: sqlDump,
        size,
        timestamp
      }
    } catch (error) {
      console.error('💥 Backup creation failed:', error)
      return {
        success: false,
        error: `Backup creation failed: ${error.message}`,
        timestamp
      }
    }
  }

  /**
   * Export all data from API endpoints
   */
  private async exportAllData(): Promise<{ success: boolean; data?: any; error?: string }> {
    try {
      const endpoints = [
        // Core data
        { name: 'patients', endpoint: '/patients' },
        { name: 'doctors', endpoint: '/doctors' },
        { name: 'employees', endpoint: '/employees' },
        
        // Transactions
        { name: 'treatments', endpoint: '/treatments' },
        { name: 'sales', endpoint: '/sales' },
        { name: 'expenses', endpoint: '/expenses' },
        { name: 'sitting_fees', endpoint: '/sitting-fees' },
        { name: 'salaries', endpoint: '/salaries' },
        
        // Field Trip
        { name: 'field_trip_products', endpoint: '/field-trip-products' },
        { name: 'field_trip_sales', endpoint: '/field-trip-sales' },
        
        // Other data
        { name: 'products', endpoint: '/products' },
        { name: 'stock_opname', endpoint: '/stock-opname' },
        { name: 'control_schedules', endpoint: '/control-schedules' },
        { name: 'dental_materials', endpoint: '/dental-materials' },
        { name: 'dental_usages', endpoint: '/dental-usages' }
      ]

      const allData: any = {}
      const results = await Promise.allSettled(
        endpoints.map(async ({ name, endpoint }) => {
          try {
            const response = await fetch(`${this.serverUrl}${endpoint}`, {
              headers: {
                'Authorization': `Bearer ${this.accessToken}`,
                'Content-Type': 'application/json'
              }
            })

            if (response.ok) {
              const data = await response.json()
              return { name, data }
            } else {
              console.warn(`⚠️ Failed to fetch ${name}: ${response.statusText}`)
              return { name, data: [] }
            }
          } catch (error) {
            console.warn(`⚠️ Error fetching ${name}:`, error)
            return { name, data: [] }
          }
        })
      )

      // Process results
      results.forEach((result, index) => {
        if (result.status === 'fulfilled') {
          const { name, data } = result.value
          allData[name] = data
        } else {
          console.warn(`⚠️ Failed to process ${endpoints[index].name}:`, result.reason)
          allData[endpoints[index].name] = []
        }
      })

      // Add metadata
      allData._metadata = {
        backup_created_at: new Date().toISOString(),
        backup_version: '1.0',
        clinic_name: 'Falasifah Dental Clinic',
        total_tables: Object.keys(allData).length - 1 // Exclude metadata
      }

      return {
        success: true,
        data: allData
      }
    } catch (error) {
      return {
        success: false,
        error: `Data export failed: ${error.message}`
      }
    }
  }

  /**
   * Generate SQL dump from exported data
   */
  private generateSQLDump(data: any, timestamp: string): string {
    const backupTimestamp = new Date(timestamp).toLocaleString('id-ID')
    
    let sqlDump = `
-- =========================================
-- FALASIFAH DENTAL CLINIC DATABASE BACKUP
-- =========================================
-- Backup Created: ${backupTimestamp}
-- Backup Version: 1.0
-- Auto Generated by Backup System
-- =========================================

-- Backup Metadata
-- Total Tables: ${Object.keys(data).length - 1}
-- Backup ID: backup-${timestamp.replace(/[^\d]/g, '').substring(0, 12)}

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

`

    // Generate SQL for each table
    for (const [tableName, tableData] of Object.entries(data)) {
      if (tableName === '_metadata' || !Array.isArray(tableData)) continue
      
      sqlDump += this.generateTableSQL(tableName, tableData as any[])
    }

    sqlDump += `
SET FOREIGN_KEY_CHECKS = 1;

-- =========================================
-- BACKUP COMPLETED SUCCESSFULLY
-- =========================================
-- Total Records: ${this.countTotalRecords(data)}
-- Backup Size: ${this.formatFileSize(new Blob([sqlDump]).size)}
-- =========================================
`

    return sqlDump
  }

  /**
   * Generate SQL for a specific table
   */
  private generateTableSQL(tableName: string, tableData: any[]): string {
    if (!tableData || tableData.length === 0) {
      return `-- Table: ${tableName} (No data)\n\n`
    }

    let sql = `
-- =========================================
-- Table: ${tableName}
-- Records: ${tableData.length}
-- =========================================

DROP TABLE IF EXISTS \`${tableName}\`;

`

    // Create table structure (simplified)
    const sampleRecord = tableData[0]
    const columns = Object.keys(sampleRecord).map(key => {
      const value = sampleRecord[key]
      let type = 'TEXT'
      
      if (typeof value === 'number') {
        type = Number.isInteger(value) ? 'INT' : 'DECIMAL(10,2)'
      } else if (typeof value === 'boolean') {
        type = 'BOOLEAN'
      } else if (key.includes('date') || key.includes('time') || key === 'created_at' || key === 'updated_at') {
        type = 'DATETIME'
      } else if (key === 'id') {
        type = 'VARCHAR(255) PRIMARY KEY'
      }
      
      return `  \`${key}\` ${type}`
    }).join(',\n')

    sql += `CREATE TABLE \`${tableName}\` (
${columns}
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

`

    // Insert data
    sql += `INSERT INTO \`${tableName}\` VALUES\n`
    
    const values = tableData.map(record => {
      const recordValues = Object.values(record).map(value => {
        if (value === null || value === undefined) {
          return 'NULL'
        } else if (typeof value === 'string') {
          return `'${value.replace(/'/g, "''")}'`
        } else if (typeof value === 'boolean') {
          return value ? '1' : '0'
        } else if (typeof value === 'object') {
          return `'${JSON.stringify(value).replace(/'/g, "''")}'`
        } else {
          return String(value)
        }
      }).join(', ')
      
      return `(${recordValues})`
    }).join(',\n')

    sql += values + ';\n\n'

    return sql
  }

  /**
   * Count total records across all tables
   */
  private countTotalRecords(data: any): number {
    let total = 0
    for (const [tableName, tableData] of Object.entries(data)) {
      if (tableName !== '_metadata' && Array.isArray(tableData)) {
        total += tableData.length
      }
    }
    return total
  }

  /**
   * Format file size for display
   */
  private formatFileSize(bytes: number): string {
    if (bytes === 0) return '0 Bytes'
    
    const k = 1024
    const sizes = ['Bytes', 'KB', 'MB', 'GB']
    const i = Math.floor(Math.log(bytes) / Math.log(k))
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]
  }

  /**
   * Test database connection
   */
  async testConnection(): Promise<{ success: boolean; error?: string }> {
    try {
      const response = await fetch(`${this.serverUrl}/patients`, {
        headers: {
          'Authorization': `Bearer ${this.accessToken}`,
          'Content-Type': 'application/json'
        }
      })

      if (response.ok) {
        return { success: true }
      } else {
        return {
          success: false,
          error: `Database connection failed: ${response.statusText}`
        }
      }
    } catch (error) {
      return {
        success: false,
        error: `Database connection error: ${error.message}`
      }
    }
  }
}

// Export factory function
export const createDatabaseBackupService = (accessToken: string, serverUrl: string) => {
  return new DatabaseBackupService(accessToken, serverUrl)
}